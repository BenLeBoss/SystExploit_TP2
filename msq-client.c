#include <stdio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <unistd.h>
#include <getopt.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

#include "msq-common.h"
#include "msq-message.h"

#define version "20200226"


/*Déclaration des sous-programmes*/


void cmHelp();

void cmVersion();


/*Programme principal*/

int main(int argc, char *argv[]){

  char *ptr;
  long messageType = 1;
  char *messageText = "This is the default message text";
  int second = 1;
  int times = 1;
  msq_message_t message;
  int projId = 1;
  int msqId;
  int option_index = 0;
  int opt_long;
  char *pathname;
  static struct option long_options[] = {
    {"help", no_argument, 0, 'h'},
    {"key-proj-id", required_argument, 0, 'i'},
    {"message-type", required_argument, 0, 'y'},
    {"key-pathname", required_argument, 0, 'p'},
    {"seconds", required_argument, 0, 's'},
    {"times", required_argument, 0, 't'},
    {"version", no_argument, 0, 'v'},
    {"message-text", required_argument, 0, 'x'},
    {0, 0, 0, 0}
 };
 pathname = NULL;

 if(msq_message_set_type(&message, messageType) == -1){
   fprintf(stderr, "%s:%s:%d: Unable to set the \"%ld\" message type.\n", argv[0], __FILE__, __LINE__, messageType);
   return 1;
 }
 if(msq_message_set_text(&message, messageText) == -1){
   fprintf(stderr, "%s:%s:%d: Unable to set the \"%s\" message text.\n", argv[0], __FILE__, __LINE__, messageText);
   return 1;
 }


  /*Options*/


  while ((opt_long = getopt_long(argc, argv, "hi:y:p:s:t:vx:", long_options, &option_index)) != -1){
      switch(opt_long){
        case 'h':
          cmHelp();
          return 0;
          break;
        case 'v':
          cmVersion();
          return 0;
          break;
        case 'i':
          if(optarg){
            projId = strtol(optarg, &ptr, 10);
            if((errno != 0) || (*ptr != '\0')){
              fprintf(stderr, "%s: Invalid parameter for the i command\n", argv[0]);
              return 1;
            }
          }
          break;
        case 'y':
        if(optarg){
          messageType = strtol(optarg, &ptr, 10);
          if((errno != 0) || (*ptr != '\0')){
            fprintf(stderr, "%s: Invalid parameter for the y command\n", argv[0]);
            return 1;
          }
          if(msq_message_set_type(&message, messageType) == -1){
            fprintf(stderr, "%s:%s:%d: Unable to set the \"%s\" message type.\n", argv[0], __FILE__, __LINE__, optarg);
            return 1;
          }
        }
          break;
        case 'x':
          if(optarg){
            if(msq_message_set_text(&message, optarg) == -1){
              fprintf(stderr, "%s:%s:%d: Unable to set the \"%s\" message text.\n", argv[0], __FILE__, __LINE__, optarg);
              return 1;
            }
          }
          break;
        case 'p':
          if(optarg){
            pathname = optarg;
          }
          break;
        case 's':
          if(optarg){
            second = strtol(optarg, &ptr, 10);
            if((errno != 0) || (*ptr != '\0')){
              fprintf(stderr, "%s: Invalid parameter for the s command\n", argv[0]);
              return 1;
            }
          }
          break;
        case 't':
          if(optarg){
            times = strtol(optarg, &ptr, 10);
            if((errno != 0) || (*ptr != '\0')){
              fprintf(stderr, "%s: Invalid parameter for the t command\n", argv[0]);
              return 1;
            }
          }
          break;
        case '?':
          return 2;
      }

  }



  /*Fin des options*/

  /*Connexion au segment de mémoire*/

  fprintf(stdout, "proj_id = \"%d\"\n", projId);
  if(pathname == NULL){
    fprintf(stdout, "pathname = \"file.ftok\"\n");
  }else{
    fprintf(stdout, "pathname = \"%s\"\n", pathname);
  }


  if(pathname != NULL){
    msqId = link_to_memory(pathname, projId, "client");
    if(msqId == -1){
      return 1;
    }
  }else{
    msqId = link_to_memory("file.ftok", projId, "client");
    if(msqId == -1){
      return 1;
    }
  }



  while(times != 0){
    if(times > 0){
      times --;
    }
    if(msgsnd(msqId, &message, MSQ_MESSAGE_TEXT_SIZE, IPC_NOWAIT) == -1){
      fprintf(stderr, "%s:%s:%d: Unable to send the message.\n", argv[0], __FILE__, __LINE__);
      return 1;
    }
    msq_message_print(message);
    if(second > 0){
      if(times != 0){
        sleep(second);
      }
    }else{
      fprintf(stdout, "Press the Enter key to continue...");
      while ((getchar()) != '\n');
    }
  }


  /*Ecriture du message*/



  return 0;
}


/*Définition des sous-programmes*/


void cmHelp(){
  fprintf(stdout, "Usage: ./msq-client.out [OPTION]...\n");
  fprintf(stdout, "Send a message to a server through a message queue.\n");
  fprintf(stdout, "\nOptions:\n");
  fprintf(stdout, "\t-h, --help\n");
  fprintf(stdout, "\t\tdisplay this help and exit\n");
  fprintf(stdout, "\t-i, --key-proj-id=PROJ_ID\n");
  fprintf(stdout, "\t\tset the key project identifier to PROJ_ID (the default value is \"1\")\n");
  fprintf(stdout, "\t-p, --key-pathname=PATHNAME\n");
  fprintf(stdout, "\t\tset the key pathname to PATHNAME (the default value is \"file.ftok\")\n");
  fprintf(stdout, "\t-s, --seconds=SECONDS\n");
  fprintf(stdout, "\t\tset the seconds between each try (the default value is \"1\", a value less than or equal to 0 enables the interactive mode where the input stream is read)\n");
  fprintf(stdout, "\t-t, --times=TIMES\n");
  fprintf(stdout, "\t\tset the number of times this program tries to send a message (the default value is \"1\", a negative value means repeat for ever)\n");
  fprintf(stdout, "\t-v, --version\n");
  fprintf(stdout, "\t\toutput version information and exit\n");
  fprintf(stdout, "\t-x, --message-text=TEXT\n");
  fprintf(stdout, "\t\tset the message text to TEXT (the default value is \"This is the default message text\")\n");
  fprintf(stdout, "\t-y, --message-type=TYPE\n");
  fprintf(stdout, "\t\tset the message type to TYPE (the default value is \"1\")\n");
  fprintf(stdout, "\nReport bugs to Benjamin Coppens Bioux <benjamin.coppens-bioux@etud.univ-pau.fr> and liam Didriche <liam.didriche@etud.univ-pau.fr>.\n");
}

void cmVersion(){
  fprintf(stdout, "msq-client %s\n", version);
  fprintf(stdout, "\nCopyright (C) 2020 Benjamin Coppens Bioux and liam Didriche.\n");
  fprintf(stdout, "\nWritten by Benjamin Coppens Bioux <benjamin.coppens-bioux@etud.univ-pau.fr> and liam Didriche <liam.didriche@etud.univ-pau.fr>.\n");
}
